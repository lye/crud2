package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strconv"
	"strings"
)

const (
	outputFilename = "z_crud2.go"
	structTagName  = "crud"
)

type StructType struct {
	TypeSpec   *ast.TypeSpec
	StructType *ast.StructType

	Name   string
	Fields StructFieldList
}

func (structType StructType) Metadata() string {
	if len(structType.Fields) == 0 {
		return ""
	}

	bs := &bytes.Buffer{}

	if er := structTemplate.Execute(bs, structType); er != nil {
		panic(er)
	}

	return bs.String()
}

type StructField struct {
	Name    string
	SqlName string
	Type    ast.Expr
}

func fileFilter(fi os.FileInfo) bool {
	name := fi.Name()

	if !strings.HasSuffix(name, ".go") {
		return false
	}

	return fi.Name() != outputFilename
}

func buildStructType(structType *StructType, astStruct *ast.StructType, prefix string) {
	for _, field := range astStruct.Fields.List {
		if field.Tag == nil {
			continue
		}

		if len(field.Names) == 0 {
			// XXX: We may want to support anonymous fields in the future.
			continue
		}

		name := field.Names[0].Name

		tagList, er := strconv.Unquote(field.Tag.Value)
		if er != nil {
			continue
		}

		rtags := reflect.StructTag(tagList)

		if tag := rtags.Get(structTagName); tag != "" {
			tagList := strings.Split(tag, ",")

			if len(tagList) > 1 {
				if tagList[1] == "recurse" {
					// The "recurse" flag is valid only on structs, and
					// indicates that all fields of the tagged struct
					// should be included as well.
					// XXX: This is a bit of a mess.
					ident, ok := field.Type.(*ast.Ident)
					if !ok {
						panic("'recurse' Field type is not an ast.Ident?")
					}
					if ident.Obj == nil || ident.Obj.Decl == nil {
						panic("'recurse' Field type doesn't refer to an object")
					}

					ts, ok := ident.Obj.Decl.(*ast.TypeSpec)
					if !ok || ts.Type == nil {
						panic("'recurse' Field type declaration doesn't ... have ... a TypeSpec?")
					}

					st, ok := ts.Type.(*ast.StructType)
					if !ok {
						panic("'recurse' field isn't a struct")
					}

					buildStructType(structType, st, prefix + name + ".")
				}
			}

			if tagList[0] != "" {
				// NB: Intentionally skip entries like `,recurse`.
				structType.Fields = append(structType.Fields, StructField{
					Name:    prefix + name,
					SqlName: tagList[0],
					Type:    field.Type,
				})
			}
		}
	}

	sort.Sort(structType.Fields)
}

func main() {
	dirPath := "."

	if len(os.Args) > 1 {
		dirPath = os.Args[1]
	}

	fset := new(token.FileSet)

	pkgs, er := parser.ParseDir(fset, dirPath, fileFilter, 0)
	if er != nil {
		log.Fatal(er)
	}

	structTypes := StructTypeList{}

	if len(pkgs) > 1 {
		log.Fatal("Multiple packages found! crudgen only supports one package at a time.")
	}

	var packageName string

	// Enumerate the AST and pull out all of the struct declarations.
	for _, pkg := range pkgs {
		packageName = pkg.Name

		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					if genDecl.Tok != token.TYPE {
						continue
					}

					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							if structType, ok := typeSpec.Type.(*ast.StructType); ok {
								structTypes = append(structTypes, &StructType{
									TypeSpec:   typeSpec,
									StructType: structType,
									Name:       typeSpec.Name.Name,
								})
							}
						}
					}
				}
			}
		}
	}
	sort.Sort(structTypes)

	// Enumerate the structs we've pulled out and parse their field declarations.
	for _, structType := range structTypes {
		buildStructType(structType, structType.StructType, "")
	}

	filePath := filepath.Join(dirPath, outputFilename)
	f, er := os.Create(filePath)
	if er != nil {
		log.Fatal(er)
	}
	defer f.Close()

	fmt.Fprintf(f, "package %s\n// AUTOGENERATED CODE. Regenerate by running crudgen.\n\nimport (\n\t\"github.com/lye/crud2\"\n)\n", packageName)

	for _, structType := range structTypes {
		fmt.Fprintf(f, "%s", structType.Metadata())
	}

	fmt.Fprintf(f, "\n")

	if er := f.Sync(); er != nil {
		log.Fatal(er)
	}
}
